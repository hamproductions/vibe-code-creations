<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Pixelator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <link rel="manifest" href="./manifest.json" />
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f0f4f8; /* Light gray background */
      }
      /* Custom scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #e2e8f0;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb {
        background: #94a3b8;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #64748b;
      }

      /* Overlay canvas for selection */
      .selection-overlay {
        position: absolute;
        top: 0;
        left: 0;
        /* width and height will be set by canvas attributes or JS, allowing them to match originalImage.clientWidth/Height */
        /* width: 100%; */ /* Removed: caused canvas element to stretch, mismatching drawing buffer size */
        /* height: 100%; */ /* Removed: caused canvas element to stretch, mismatching drawing buffer size */
        pointer-events: none; /* Allows clicks to pass through to the image below when not drawing */
        z-index: 10; /* Ensures it's above the image */
      }
    </style>
  </head>
  <body class="min-h-screen flex items-center justify-center p-4">
    <div
      class="bg-white p-8 rounded-xl shadow-lg w-full max-w-4xl border border-gray-200"
    >
      <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
        Pixelator
      </h1>

      <div class="flex flex-col gap-6 mb-6">
        <!-- Original Image Section -->
        <div
          class="w-full border-2 border-dashed border-gray-300 rounded-lg p-4 flex flex-col items-center justify-center bg-gray-50 relative"
        >
          <!-- Selection Overlay Canvas -->
          <canvas id="selectionCanvas" class="selection-overlay"></canvas>

          <label
            for="imageUpload"
            class="cursor-pointer bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out mb-4 z-20 flex items-center"
          >
            <i class="fas fa-upload mr-2"></i>Upload Image
            <input
              type="file"
              id="imageUpload"
              accept="image/*"
              class="hidden"
            />
          </label>
          <div
            id="originalImageContainer"
            class="overflow-auto rounded-lg shadow-inner border border-gray-200 w-full relative min-h-[200px] md:min-h-[250px] flex flex-col items-center justify-center"
          >
            <img
              id="originalImage"
              class="max-w-full h-auto hidden rounded-lg"
              alt="Original Image"
            />
            <p id="uploadPrompt" class="text-gray-500 text-center py-8 px-4">
              No image uploaded yet. Click "Upload Image" or drag & drop a file
              here to begin.
            </p>
          </div>
        </div>

        <!-- Pixelated Image Section -->
        <div class="w-full mx-auto flex flex-col items-center mt-4">
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Pixelated Image
          </h2>
          <div
            id="pixelatedImageContainer"
            class="relative w-full min-h-[150px] md:min-h-[200px] overflow-auto rounded-lg shadow-inner border border-gray-200 bg-gray-100"
          >
            <canvas
              id="pixelatedCanvas"
              class="block mx-auto rounded-lg"
            ></canvas>
            <p
              id="canvasPrompt"
              class="absolute inset-0 flex items-center justify-center text-gray-500 rounded-lg text-center"
            >
              Your pixelated image will appear here.
            </p>
          </div>
          <button
            id="downloadBtn"
            class="mt-4 bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out hidden flex items-center"
          >
            <i class="fas fa-download mr-2"></i>Download
          </button>
        </div>
      </div>

      <!-- Controls Section -->
      <div
        id="controlsContainer"
        class="bg-gray-100 p-4 rounded-lg shadow-inner space-y-3"
      >
        <!-- Row 1: Main Pixelation & Tool Selection -->
        <div class="flex flex-wrap items-center justify-between gap-4">
          <!-- Pixelation Level Group -->
          <div class="flex items-center gap-2 flex-grow sm:flex-grow-0">
            <label
              for="pixelationRange"
              class="text-gray-700 font-medium whitespace-nowrap"
              >Level:</label
            >
            <input
              type="range"
              id="pixelationRange"
              min="1"
              max="50"
              value="10"
              class="flex-grow w-full md:w-auto h-2 rounded-lg appearance-none cursor-pointer bg-blue-200"
              oninput="this.nextElementSibling.value = this.value"
            />
            <output
              for="pixelationRange"
              class="text-blue-600 font-bold w-10 text-center"
              >10</output
            >
          </div>

          <!-- Tool Selection Group -->
          <div class="flex items-center gap-2">
            <span class="text-gray-700 font-medium">Tool:</span>
            <button
              id="toolToggleBtn"
              class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out"
              title="Switch to Brush Tool"
            >
              <i class="fas fa-vector-square"></i>
              <!-- Default to Rectangle -->
            </button>
          </div>
        </div>

        <!-- Row 2: Brush Specific Controls (conditionally visible) -->
        <div
          id="brushSpecificControls"
          class="hidden flex-wrap items-center justify-start gap-x-4 gap-y-2 border-t border-gray-200 pt-3 mt-3"
        >
          <div class="flex items-center gap-2">
            <label
              for="brushSizeRange"
              class="text-gray-700 font-medium whitespace-nowrap"
              >Size:</label
            >
            <input
              type="range"
              id="brushSizeRange"
              min="5"
              max="100"
              value="20"
              class="w-full md:w-auto h-2 rounded-lg appearance-none cursor-pointer bg-pink-200"
              oninput="this.nextElementSibling.value = this.value"
            />
            <output
              for="brushSizeRange"
              class="text-pink-600 font-bold w-10 text-center"
              >20</output
            >
          </div>
          <div class="flex items-center gap-2">
            <span class="text-gray-700 font-medium">Mode:</span>
            <button
              id="brushModeToggleBtn"
              class="bg-teal-500 hover:bg-teal-600 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out"
              title="Switch to Eraser"
            >
              <i class="fas fa-paint-brush"></i>
              <!-- Default to Draw -->
            </button>
          </div>
        </div>

        <!-- Row 3: Action Buttons -->
        <div
          class="flex flex-wrap items-center justify-center gap-2 border-t border-gray-200 pt-3 mt-3"
        >
          <button
            id="pixelateWholeBtn"
            class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out flex items-center"
          >
            <i class="fas fa-th-large mr-2"></i>All
          </button>
          <button
            id="pixelateSelectionBtn"
            class="bg-orange-500 hover:bg-orange-600 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out hidden flex items-center"
          >
            <i class="fas fa-crop-alt mr-2"></i>Selection
          </button>
          <button
            id="clearSelectionBtn"
            class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out hidden"
            title="Clear Selection"
          >
            <i class="fas fa-trash-alt"></i> Clear
          </button>
          <button
            id="undoBtn"
            class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-3 rounded-lg shadow-md transition duration-300 ease-in-out hidden"
            title="Undo"
          >
            <i class="fas fa-undo"></i> Undo
          </button>
        </div>
      </div>

      <!-- Message Box -->
      <div
        id="messageBox"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden"
      >
        <div
          class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm w-full"
        >
          <p id="messageText" class="text-gray-800 text-lg mb-4"></p>
          <button
            id="closeMessageBtn"
            class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300 ease-in-out flex items-center"
          >
            <i class="fas fa-times mr-2"></i>Close
          </button>
        </div>
      </div>
    </div>

    <script>
      // Get DOM elements
      const imageUpload = document.getElementById("imageUpload");
      const originalImage = document.getElementById("originalImage");
      const originalImageContainer = document.getElementById(
        "originalImageContainer"
      );
      const uploadPrompt = document.getElementById("uploadPrompt");
      const pixelatedCanvas = document.getElementById("pixelatedCanvas");
      const canvasPrompt = document.getElementById("canvasPrompt");
      const pixelateWholeBtn = document.getElementById("pixelateWholeBtn");
      const pixelateSelectionBtn = document.getElementById(
        "pixelateSelectionBtn"
      );
      const clearSelectionBtn = document.getElementById("clearSelectionBtn");
      const pixelationRange = document.getElementById("pixelationRange");
      const downloadBtn = document.getElementById("downloadBtn");
      const messageBox = document.getElementById("messageBox");
      const messageText = document.getElementById("messageText");
      const closeMessageBtn = document.getElementById("closeMessageBtn");
      const selectionCanvas = document.getElementById("selectionCanvas");
      const toolToggleBtn = document.getElementById("toolToggleBtn");
      const brushSpecificControls = document.getElementById(
        "brushSpecificControls"
      );
      const brushSizeRange = document.getElementById("brushSizeRange");
      const brushModeToggleBtn = document.getElementById("brushModeToggleBtn");
      const undoBtn = document.getElementById("undoBtn");
      const pixelatedImageContainer = document.getElementById(
        "pixelatedImageContainer"
      );

      let uploadedImage = null; // Stores the Image object once uploaded
      const ctx = pixelatedCanvas.getContext("2d"); // Context for pixelated image
      const selectionCtx = selectionCanvas.getContext("2d", {
        willReadFrequently: true
      }); // Context for selection overlay

      // Selection variables
      let isSelecting = false;
      let isBrushing = false; // For brush selection
      let startX = 0;
      let startY = 0;
      let selectionRect = null; // { x, y, width, height } in original image coordinates
      let activeTool = "rectangle"; // 'rectangle' or 'brush', default to rectangle
      let brushMode = "draw"; // 'draw' or 'erase'
      let currentBrushSize = parseInt(brushSizeRange.value);
      let lastBrushPoint = { x: 0, y: 0 };

      const MAX_HISTORY_SIZE = 20;
      let selectionHistory = [];
      let currentHistoryIndex = -1;

      // Function to show a custom message box instead of alert()
      function showMessageBox(message) {
        messageText.textContent = message;
        messageBox.classList.remove("hidden");
      }

      // Event listener for closing the message box
      closeMessageBtn.addEventListener("click", () => {
        messageBox.classList.add("hidden");
      });

      function _handleImageLoadError(errorMessage) {
        showMessageBox(errorMessage);
        uploadedImage = null;
        originalImage.classList.add("hidden");
        uploadPrompt.classList.remove("hidden");
        originalImageContainer.classList.add("items-center", "justify-center");
        selectionCanvas.style.pointerEvents = "none";

        if (pixelatedCanvas.width > 0 && pixelatedCanvas.height > 0) {
          ctx.clearRect(0, 0, pixelatedCanvas.width, pixelatedCanvas.height);
        }
        pixelatedCanvas.width = 1;
        pixelatedCanvas.height = 1;
        pixelatedCanvas.style.width = "";
        pixelatedCanvas.style.height = "";
        pixelatedImageContainer.style.minHeight = ""; // Revert to CSS defined
        canvasPrompt.classList.remove("hidden");
        downloadBtn.classList.add("hidden");

        clearSelection();
        selectionHistory = [];
        currentHistoryIndex = -1;
        updateUndoButtonState();
      }

      function saveSelectionState() {
        if (
          !selectionCanvas ||
          selectionCanvas.width === 0 ||
          selectionCanvas.height === 0
        )
          return;
        const imageData = selectionCtx.getImageData(
          0,
          0,
          selectionCanvas.width,
          selectionCanvas.height
        );

        // Clear redo stack if we are not at the end of history
        if (currentHistoryIndex < selectionHistory.length - 1) {
          selectionHistory = selectionHistory.slice(0, currentHistoryIndex + 1);
        }

        selectionHistory.push(imageData);
        if (selectionHistory.length > MAX_HISTORY_SIZE) {
          selectionHistory.shift(); // Remove oldest entry
        } else {
          currentHistoryIndex++;
        }
        updateUndoButtonState();
      }

      function isSelectionCanvasEmpty() {
        if (
          !selectionCanvas ||
          selectionCanvas.width === 0 ||
          selectionCanvas.height === 0
        )
          return true;
        const data = selectionCtx.getImageData(
          0,
          0,
          selectionCanvas.width,
          selectionCanvas.height
        ).data;
        for (let i = 3; i < data.length; i += 4) {
          // Check alpha channel
          if (data[i] > 50) return false; // Found a sufficiently non-transparent pixel
        }
        return true;
      }

      function updateSelectionButtonsVisibility() {
        const isEmpty = isSelectionCanvasEmpty();
        if (isEmpty && !selectionRect) {
          // selectionRect check for rectangle tool
          pixelateSelectionBtn.classList.add("hidden");
          clearSelectionBtn.classList.add("hidden");
        } else {
          pixelateSelectionBtn.classList.remove("hidden");
          clearSelectionBtn.classList.remove("hidden");
        }
      }

      // Function to clear the selection rectangle and hide relevant buttons
      function clearSelection() {
        selectionCtx.clearRect(
          0,
          0,
          selectionCanvas.width,
          selectionCanvas.height
        );
        pixelateSelectionBtn.classList.add("hidden");
        clearSelectionBtn.classList.add("hidden");
        isBrushing = false;
        selectionRect = null;
        saveSelectionState(); // Save the cleared state for undo
      }

      // Function to draw the selection rectangle
      function drawSelectionRect(x, y, width, height) {
        selectionCtx.clearRect(
          0,
          0,
          selectionCanvas.width,
          selectionCanvas.height
        );
        selectionCtx.strokeStyle = "rgba(0, 123, 255, 0.9)"; // Blue border
        selectionCtx.lineWidth = 2;
        selectionCtx.setLineDash([5, 5]); // Dashed line
        selectionCtx.strokeRect(x, y, width, height);

        selectionCtx.fillStyle = "rgba(0, 123, 255, 0.05)"; // Lighter blue fill
        selectionCtx.fillRect(x, y, width, height);
      }

      // Function to draw brush strokes
      function drawBrushStroke(x1, y1, x2, y2) {
        selectionCtx.save();
        if (brushMode === "erase") {
          selectionCtx.globalCompositeOperation = "destination-out";
        } else {
          selectionCtx.globalCompositeOperation = "source-over";
        }
        selectionCtx.beginPath();
        selectionCtx.moveTo(x1, y1);
        selectionCtx.lineTo(x2, y2);
        selectionCtx.strokeStyle = "rgba(0, 123, 255, 0.25)"; // More transparent blue for mask
        selectionCtx.lineWidth = currentBrushSize;
        selectionCtx.lineCap = "round";
        selectionCtx.lineJoin = "round";
        selectionCtx.stroke();
        selectionCtx.restore();
      }

      function updateToolUI() {
        if (activeTool === "brush") {
          toolToggleBtn.innerHTML = '<i class="fas fa-paint-brush"></i>'; // Show brush icon
          toolToggleBtn.title = "Switch to Rectangle Tool";
          brushSpecificControls.classList.remove("hidden");
          brushSpecificControls.classList.add("flex"); // Ensure it's flex for proper layout
          brushModeToggleBtn.classList.remove("hidden");
          if (selectionRect) clearSelection(); // Clear rect selection when switching to brush
        } else {
          // rectangle
          toolToggleBtn.innerHTML = '<i class="fas fa-vector-square"></i>'; // Show rectangle icon
          toolToggleBtn.title = "Switch to Brush Tool";

          brushSpecificControls.classList.add("hidden");
          brushSpecificControls.classList.remove("flex");
          // brushModeToggleBtn is inside brushSpecificControls, so it's hidden too
          // Clear brush mask if switching to rectangle
          selectionCtx.clearRect(
            0,
            0,
            selectionCanvas.width,
            selectionCanvas.height
          );
          if (isBrushing || !isSelectionCanvasEmpty()) saveSelectionState(); // Save cleared state if brush was active
        }
      }

      toolToggleBtn.addEventListener("click", () => {
        activeTool = activeTool === "rectangle" ? "brush" : "rectangle";
        clearSelection(); // Clear any existing selection when toggling tool
        updateToolUI();
      });

      brushSizeRange.addEventListener("input", (e) => {
        currentBrushSize = parseInt(e.target.value);
        e.target.nextElementSibling.value = e.target.value;
      });

      brushModeToggleBtn.addEventListener("click", () => {
        if (brushMode === "draw") {
          brushMode = "erase";
          brushModeToggleBtn.innerHTML = '<i class="fas fa-eraser"></i>'; // Show eraser icon
          brushModeToggleBtn.title = "Switch to Draw Mode";
        } else {
          brushMode = "draw";
          brushModeToggleBtn.innerHTML = '<i class="fas fa-paint-brush"></i>'; // Show brush icon
          brushModeToggleBtn.title = "Switch to Erase Mode";
        }
      });

      // Event listeners for selection on selectionCanvas
      selectionCanvas.addEventListener("mousedown", (e) => {
        if (!uploadedImage) return; // Only allow selection if an image is loaded

        const canvasRect = selectionCanvas.getBoundingClientRect();
        const currentX = e.clientX - canvasRect.left;
        const currentY = e.clientY - canvasRect.top;

        if (activeTool === "rectangle") {
          isSelecting = true;
          startX = currentX;
          startY = currentY;
        } else if (activeTool === "brush") {
          isBrushing = true;
          lastBrushPoint = { x: currentX, y: currentY };
          selectionCtx.save();
          if (brushMode === "erase") {
            selectionCtx.globalCompositeOperation = "destination-out";
          } else {
            selectionCtx.globalCompositeOperation = "source-over";
          }

          selectionCtx.beginPath();
          selectionCtx.arc(
            currentX,
            currentY,
            currentBrushSize / 2,
            0,
            Math.PI * 2
          );
          selectionCtx.fillStyle = "rgba(0, 123, 255, 0.25)";
          selectionCtx.fill();
          selectionCtx.restore();
          updateSelectionButtonsVisibility();
        }
      });

      selectionCanvas.addEventListener("mousemove", (e) => {
        if (!uploadedImage) return;
        const canvasRect = selectionCanvas.getBoundingClientRect();
        const currentX = e.clientX - canvasRect.left;
        const currentY = e.clientY - canvasRect.top;

        if (activeTool === "rectangle" && isSelecting) {
          const width = currentX - startX;
          const height = currentY - startY;
          drawSelectionRect(startX, startY, width, height);
        } else if (activeTool === "brush" && isBrushing) {
          drawBrushStroke(
            lastBrushPoint.x,
            lastBrushPoint.y,
            currentX,
            currentY
          );
          lastBrushPoint = { x: currentX, y: currentY };
        }
      });

      // Touch event listeners for selectionCanvas
      selectionCanvas.addEventListener("touchstart", (e) => {
        if (!uploadedImage) return;
        e.preventDefault(); // Prevent scrolling/zooming
        const touch = e.touches[0];
        const canvasRect = selectionCanvas.getBoundingClientRect();
        const currentX = touch.clientX - canvasRect.left;
        const currentY = touch.clientY - canvasRect.top;

        if (activeTool === "rectangle") {
          isSelecting = true;
          startX = currentX;
          startY = currentY;
        } else if (activeTool === "brush") {
          isBrushing = true;
          lastBrushPoint = { x: currentX, y: currentY };
          selectionCtx.save();
          if (brushMode === "erase") {
            selectionCtx.globalCompositeOperation = "destination-out";
          } else {
            selectionCtx.globalCompositeOperation = "source-over";
          }
          selectionCtx.beginPath();
          selectionCtx.arc(
            currentX,
            currentY,
            currentBrushSize / 2,
            0,
            Math.PI * 2
          );
          selectionCtx.fillStyle = "rgba(0, 123, 255, 0.25)";
          selectionCtx.fill();
          selectionCtx.restore();
          updateSelectionButtonsVisibility();
        }
      });

      selectionCanvas.addEventListener("touchmove", (e) => {
        if (!uploadedImage) return;
        e.preventDefault(); // Prevent scrolling/zooming
        const touch = e.touches[0];
        const canvasRect = selectionCanvas.getBoundingClientRect();
        const currentX = touch.clientX - canvasRect.left;
        const currentY = touch.clientY - canvasRect.top;

        if (activeTool === "rectangle" && isSelecting) {
          const width = currentX - startX;
          const height = currentY - startY;
          drawSelectionRect(startX, startY, width, height);
        } else if (activeTool === "brush" && isBrushing) {
          drawBrushStroke(
            lastBrushPoint.x,
            lastBrushPoint.y,
            currentX,
            currentY
          );
          lastBrushPoint = { x: currentX, y: currentY };
        }
      });

      selectionCanvas.addEventListener("mouseup", (e) => {
        if (!uploadedImage) return;

        if (activeTool === "rectangle" && isSelecting) {
          isSelecting = false;

          const canvasRect = selectionCanvas.getBoundingClientRect();
          const endX = e.clientX - canvasRect.left;
          const endY = e.clientY - canvasRect.top;

          const x = Math.min(startX, endX);
          const y = Math.min(startY, endY);
          const width = Math.abs(endX - startX);
          const height = Math.abs(endY - startY);

          if (width > 5 && height > 5) {
            const scaleX =
              uploadedImage.naturalWidth / originalImage.clientWidth;
            const scaleY =
              uploadedImage.naturalHeight / originalImage.clientHeight;
            selectionRect = {
              x: Math.floor(x * scaleX),
              y: Math.floor(y * scaleY),
              width: Math.floor(width * scaleX),
              height: Math.floor(height * scaleY)
            };
            pixelateSelectionBtn.classList.remove("hidden");
            clearSelectionBtn.classList.remove("hidden");
          } else {
            clearSelection();
          }
        } else if (activeTool === "brush" && isBrushing) {
          isBrushing = false;
          saveSelectionState(); // Save after brush stroke is complete
          // Brush mask is already on selectionCanvas
        }
      });

      selectionCanvas.addEventListener("touchend", (e) => {
        if (!uploadedImage) return;
        e.preventDefault();
        const touch = e.changedTouches[0]; // Use changedTouches for touchend

        if (activeTool === "rectangle" && isSelecting) {
          isSelecting = false;
          const canvasRect = selectionCanvas.getBoundingClientRect();
          const endX = touch.clientX - canvasRect.left;
          const endY = touch.clientY - canvasRect.top;

          const x = Math.min(startX, endX);
          const y = Math.min(startY, endY);
          const width = Math.abs(endX - startX);
          const height = Math.abs(endY - startY);

          if (width > 5 && height > 5) {
            const scaleX =
              uploadedImage.naturalWidth / originalImage.clientWidth;
            const scaleY =
              uploadedImage.naturalHeight / originalImage.clientHeight;
            selectionRect = {
              x: Math.floor(x * scaleX),
              y: Math.floor(y * scaleY),
              width: Math.floor(width * scaleX),
              height: Math.floor(height * scaleY)
            };
            pixelateSelectionBtn.classList.remove("hidden");
            clearSelectionBtn.classList.remove("hidden");
          } else {
            clearSelection();
          }
        } else if (activeTool === "brush" && isBrushing) {
          isBrushing = false;
          saveSelectionState();
        }
      });

      selectionCanvas.addEventListener("mouseleave", () => {
        if (activeTool === "rectangle" && isSelecting) {
          isSelecting = false;
          clearSelection();
        } else if (activeTool === "brush" && isBrushing) {
          isBrushing = false;
          saveSelectionState(); // Save if brush leaves canvas mid-stroke
          // Keep the drawn brush strokes
        }
      });

      selectionCanvas.addEventListener("touchcancel", (e) => {
        if (!uploadedImage) return;
        e.preventDefault();
        if (activeTool === "rectangle" && isSelecting) {
          isSelecting = false;
          clearSelection();
        } else if (activeTool === "brush" && isBrushing) {
          isBrushing = false;
          saveSelectionState();
        }
      });

      function handleImageFile(file) {
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              uploadedImage = img;
              originalImage.src = e.target.result;
              originalImage.classList.remove("hidden");
              uploadPrompt.classList.add("hidden");
              originalImageContainer.classList.remove(
                "items-center",
                "justify-center"
              ); // Allow image to fill
              updateToolUI();

              const canvasOffsetParent =
                selectionCanvas.offsetParent || document.body;
              const offsetParentRect =
                canvasOffsetParent.getBoundingClientRect();
              const imgRect = originalImage.getBoundingClientRect();

              // Size selection canvas to displayed image
              selectionCanvas.width = originalImage.clientWidth;
              selectionCanvas.height = originalImage.clientHeight;
              selectionCanvas.style.left =
                imgRect.left - offsetParentRect.left + "px";
              selectionCanvas.style.top =
                imgRect.top - offsetParentRect.top + "px";
              selectionCanvas.style.pointerEvents = "auto";

              // Size pixelated canvas buffer to natural image size
              pixelatedCanvas.width = uploadedImage.naturalWidth;
              pixelatedCanvas.height = uploadedImage.naturalHeight;
              // Size pixelated canvas display to match original image display
              pixelatedCanvas.style.width = originalImage.clientWidth + "px";
              pixelatedCanvas.style.height = originalImage.clientHeight + "px";
              pixelatedImageContainer.style.minHeight = "0"; // Allow canvas to dictate height

              selectionHistory = [];
              currentHistoryIndex = -1;
              clearSelection();

              pixelateImage();
            };
            img.onerror = () => {
              _handleImageLoadError(
                "Could not load image. Please try a different file."
              );
            };
            img.src = e.target.result;
          };
          reader.onerror = () => {
            _handleImageLoadError(
              "Error reading file. Please check the file and try again."
            );
          };
          reader.readAsDataURL(file);
        } else {
          showMessageBox("No file provided or file is not an image.");
        }
      }

      imageUpload.addEventListener("change", (event) => {
        const file = event.target.files[0];
        handleImageFile(file);
        event.target.value = null; // Reset file input
      });

      // Function to pixelate the image or a portion of it
      // Takes an optional 'region' argument { x, y, width, height } in original image coordinates
      // Takes an optional 'useBrushMask' boolean
      function pixelateImage(region = null, useBrushMask = false) {
        if (!uploadedImage) {
          showMessageBox("Please upload an image first.");
          return;
        }

        canvasPrompt.classList.add("hidden");
        downloadBtn.classList.remove("hidden");

        const originalWidth = uploadedImage.naturalWidth;
        const originalHeight = uploadedImage.naturalHeight;

        // Draw original image onto a temporary canvas to get pixel data
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d", {
          willReadFrequently: true
        });
        tempCanvas.width = originalWidth;
        tempCanvas.height = originalHeight;
        tempCtx.drawImage(uploadedImage, 0, 0);

        const pixelSize = parseInt(pixelationRange.value);

        // If pixelating the whole image (no specific region, no brush mask),
        // ensure the canvas is set up. The caller (slider/button) should set the base image if needed.
        if (!region && !useBrushMask) {
          if (
            pixelatedCanvas.width !== originalWidth ||
            pixelatedCanvas.height !== originalHeight
          ) {
            pixelatedCanvas.width = originalWidth;
            pixelatedCanvas.height = originalHeight;
          }
          // For whole image pixelation, draw the original image as a base first.
          ctx.drawImage(uploadedImage, 0, 0, originalWidth, originalHeight);
        }
        // For region or brush mask, assume pixelatedCanvas already has the base (e.g., original image)

        if (useBrushMask) {
          const scaleXOriginalToDisplay =
            originalImage.clientWidth / originalWidth;
          const scaleYOriginalToDisplay =
            originalImage.clientHeight / originalHeight;
          let selectionMaskData = null;
          try {
            selectionMaskData = selectionCtx.getImageData(
              0,
              0,
              selectionCanvas.width,
              selectionCanvas.height
            ).data;
          } catch (e) {
            console.error("Error getting selection mask data: ", e);
            showMessageBox(
              "Could not process brush selection. Canvas might be tainted if image is from cross-origin source without CORS headers."
            );
            return;
          }

          for (let yOrig = 0; yOrig < originalHeight; yOrig += pixelSize) {
            for (let xOrig = 0; xOrig < originalWidth; xOrig += pixelSize) {
              const blockCenterXOrig = xOrig + pixelSize / 2;
              const blockCenterYOrig = yOrig + pixelSize / 2;

              const scX = Math.floor(
                blockCenterXOrig * scaleXOriginalToDisplay
              );
              const scY = Math.floor(
                blockCenterYOrig * scaleYOriginalToDisplay
              );

              if (
                scX >= 0 &&
                scX < selectionCanvas.width &&
                scY >= 0 &&
                scY < selectionCanvas.height
              ) {
                const maskPixelIndex = (scY * selectionCanvas.width + scX) * 4;
                if (
                  selectionMaskData &&
                  selectionMaskData[maskPixelIndex + 3] > 50
                ) {
                  // Check alpha of brush stroke
                  pixelateBlock(
                    tempCtx,
                    ctx,
                    xOrig,
                    yOrig,
                    pixelSize,
                    originalWidth,
                    originalHeight
                  );
                }
              }
            }
          }
        } else {
          // Rectangle region or whole image
          const startPixelX = region ? Math.max(0, region.x) : 0;
          const startPixelY = region ? Math.max(0, region.y) : 0;
          const endPixelX = region
            ? Math.min(originalWidth, region.x + region.width)
            : originalWidth;
          const endPixelY = region
            ? Math.min(originalHeight, region.y + region.height)
            : originalHeight;

          for (let y = startPixelY; y < endPixelY; y += pixelSize) {
            for (let x = startPixelX; x < endPixelX; x += pixelSize) {
              pixelateBlock(
                tempCtx,
                ctx,
                x,
                y,
                pixelSize,
                endPixelX,
                endPixelY,
                region
              );
            }
          }
        }
      }

      function pixelateBlock(
        sourceContext,
        targetContext,
        x,
        y,
        blockSize,
        maxX,
        maxY,
        region = null
      ) {
        const blockX = x;
        const blockY = y;
        // Adjust block dimensions if it's near the edge of the image or region
        const blockWidth = Math.min(
          blockSize,
          (region ? region.x + region.width : maxX) - blockX
        );
        const blockHeight = Math.min(
          blockSize,
          (region ? region.y + region.height : maxY) - blockY
        );

        if (blockWidth <= 0 || blockHeight <= 0) return;

        const imageData = sourceContext.getImageData(
          blockX,
          blockY,
          blockWidth,
          blockHeight
        );
        const pixels = imageData.data;

        let red = 0;
        let green = 0;
        let blue = 0;
        let alpha = 0;
        let count = 0;

        // Calculate average color for the block
        for (let i = 0; i < pixels.length; i += 4) {
          red += pixels[i];
          green += pixels[i + 1];
          blue += pixels[i + 2];
          alpha += pixels[i + 3];
          count++;
        }

        if (count > 0) {
          red = Math.floor(red / count);
          green = Math.floor(green / count);
          blue = Math.floor(blue / count);
          alpha = Math.floor(alpha / count);
        }

        // Draw a rectangle with the average color onto the visible pixelated canvas
        targetContext.fillStyle = `rgba(${red}, ${green}, ${blue}, ${
          alpha / 255
        })`;
        targetContext.fillRect(blockX, blockY, blockWidth, blockHeight);
      }

      function isBrushMaskNonEmpty() {
        if (
          !selectionCanvas ||
          selectionCanvas.width === 0 ||
          selectionCanvas.height === 0
        )
          return false;
        // Don't check getImageData here for performance, rely on isBrushing or button states.
        // A more robust check could be done if needed but might be slow.
        // For now, if clearSelectionBtn is visible and activeTool is brush, assume mask might be non-empty.
        // This function is primarily for the slider logic.
        // A simple check: if the clearSelectionBtn is visible and it's brush mode.
        return (
          activeTool === "brush" &&
          !clearSelectionBtn.classList.contains("hidden")
        );
      }

      // Event listener for pixelate whole image button click
      pixelateWholeBtn.addEventListener("click", () => {
        if (!uploadedImage) {
          showMessageBox("Please upload an image first.");
          return;
        }
        pixelatedCanvas.width = uploadedImage.naturalWidth;
        pixelatedCanvas.height = uploadedImage.naturalHeight;
        // pixelateImage(null, false) will draw original then pixelate
        pixelateImage(null, false);
      });

      // Event listener for pixelate selection button click
      pixelateSelectionBtn.addEventListener("click", () => {
        if (!uploadedImage) {
          showMessageBox("Please upload an image first.");
          return;
        }

        pixelatedCanvas.width = uploadedImage.naturalWidth;
        pixelatedCanvas.height = uploadedImage.naturalHeight;
        ctx.drawImage(
          uploadedImage,
          0,
          0,
          uploadedImage.naturalWidth,
          uploadedImage.naturalHeight
        );

        if (activeTool === "brush" && isBrushMaskNonEmpty()) {
          pixelateImage(null, true);
        } else if (activeTool === "rectangle" && selectionRect) {
          pixelateImage(selectionRect, false);
        } else {
          showMessageBox(
            "No selection made or active. Please select an area or use 'Pixelate Whole Image'."
          );
          // Revert to showing the original image if no selection was actually processed
          ctx.drawImage(
            uploadedImage,
            0,
            0,
            uploadedImage.naturalWidth,
            uploadedImage.naturalHeight
          );
          pixelateImage(null, false); // Or pixelate whole as a fallback
        }
      });

      // Event listener for clear selection button
      clearSelectionBtn.addEventListener("click", clearSelection);

      // Event listener for slider change
      pixelationRange.addEventListener("input", () => {
        if (!uploadedImage) return;

        pixelatedCanvas.width = uploadedImage.naturalWidth;
        pixelatedCanvas.height = uploadedImage.naturalHeight;
        ctx.drawImage(
          uploadedImage,
          0,
          0,
          uploadedImage.naturalWidth,
          uploadedImage.naturalHeight
        );

        if (activeTool === "brush" && isBrushMaskNonEmpty()) {
          pixelateImage(null, true);
        } else if (activeTool === "rectangle" && selectionRect) {
          pixelateImage(selectionRect, false);
        } else {
          // If no selection, pixelate whole image by default when slider changes
          pixelateImage(null, false); // Pixelate whole image
        }
      });

      // Event listener for download button
      downloadBtn.addEventListener("click", () => {
        if (
          pixelatedCanvas.width === 0 ||
          pixelatedCanvas.height === 0 ||
          !uploadedImage
        ) {
          showMessageBox(
            "No pixelated image to download. Please upload and pixelate an image first."
          );
          return;
        }
        const dataURL = pixelatedCanvas.toDataURL("image/png"); // Get image data as PNG
        const a = document.createElement("a");
        a.href = dataURL;
        a.download = "pixelated-image.png"; // Suggested filename
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });

      // Ensure canvas and image containers resize responsively
      window.addEventListener("resize", () => {
        if (uploadedImage) {
          // Allow originalImage to resize, then get its new dimensions
          // Using a microtask to ensure layout has updated
          requestAnimationFrame(() => {
            if (!uploadedImage) return; // Check again in case image was cleared

            const imgRect = originalImage.getBoundingClientRect();
            if (imgRect.width === 0 || imgRect.height === 0) return; // Image not visible or sized

            pixelatedCanvas.style.width = originalImage.clientWidth + "px";
            pixelatedCanvas.style.height = originalImage.clientHeight + "px";

            const canvasOffsetParent =
              selectionCanvas.offsetParent || document.body;
            const offsetParentRect = canvasOffsetParent.getBoundingClientRect();
            selectionCanvas.width = originalImage.clientWidth;
            selectionCanvas.height = originalImage.clientHeight;
            selectionCanvas.style.left =
              imgRect.left - offsetParentRect.left + "px";
            selectionCanvas.style.top =
              imgRect.top - offsetParentRect.top + "px";
            selectionCanvas.style.pointerEvents = uploadedImage
              ? "auto"
              : "none";

            clearSelection();
            updateToolUI();
            pixelateImage(null, false);
          });
        }
      });

      // Drag and Drop
      originalImageContainer.addEventListener("dragover", (event) => {
        event.preventDefault();
        event.stopPropagation();
        originalImageContainer.classList.add("border-blue-500", "bg-blue-50");
      });

      originalImageContainer.addEventListener("dragleave", (event) => {
        event.preventDefault();
        event.stopPropagation();
        originalImageContainer.classList.remove(
          "border-blue-500",
          "bg-blue-50"
        );
      });

      originalImageContainer.addEventListener("drop", (event) => {
        event.preventDefault();
        event.stopPropagation();
        originalImageContainer.classList.remove(
          "border-blue-500",
          "bg-blue-50"
        );
        const file = event.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          handleImageFile(file);
        } else {
          showMessageBox("Please drop an image file.");
        }
      });

      function updateUndoButtonState() {
        if (currentHistoryIndex > 0) {
          // Can undo if not at the initial state
          undoBtn.classList.remove("hidden");
        } else {
          undoBtn.classList.add("hidden");
        }
      }

      undoBtn.addEventListener("click", () => {
        if (currentHistoryIndex > 0) {
          currentHistoryIndex--;
          const imageData = selectionHistory[currentHistoryIndex];
          selectionCtx.clearRect(
            0,
            0,
            selectionCanvas.width,
            selectionCanvas.height
          );
          selectionCtx.putImageData(imageData, 0, 0);

          // After undo, selectionRect might be invalid, clear it.
          // Brush mask is implicitly handled by putImageData.
          selectionRect = null;
          updateSelectionButtonsVisibility(); // Check if canvas is empty now
        }
        updateUndoButtonState();
      });

      // Initial setup for prompts and button visibility
      canvasPrompt.classList.remove("hidden");
      uploadPrompt.classList.remove("hidden");
      originalImageContainer.classList.add("items-center", "justify-center");
      originalImage.classList.add("hidden");
      downloadBtn.classList.add("hidden");
      pixelateSelectionBtn.classList.add("hidden"); // Hide until selection is made
      clearSelectionBtn.classList.add("hidden"); // Hide until selection is made
      undoBtn.classList.add("hidden");
      updateToolUI(); // Set initial tool UI
    </script>
  </body>
</html>
