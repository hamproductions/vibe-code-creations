<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Darts 501 Scoreboard</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style type="text/tailwindcss">
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-tap {
            transition: all 0.1s ease-in-out;
        }
        .btn-tap:active {
            transform: scale(0.95);
            filter: brightness(0.9);
        }
        .toggle-bg:after {
            content: '';
            @apply absolute top-0.5 left-0.5 bg-white border border-gray-300 rounded-full h-5 w-5 transition-transform;
        }
        input:checked + .toggle-bg:after {
            @apply transform translate-x-full;
        }
        input:checked + .toggle-bg {
            @apply bg-indigo-600 border-indigo-600;
        }
        :disabled {
            @apply opacity-50 cursor-not-allowed;
        }
        /* Custom Scrollbar for History */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #c7c7c7;
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a0a0a0;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white h-full md:h-screen overflow-auto md:overflow-hidden">

    <div id="app-root" class="min-h-full p-4 md:p-8 grid grid-cols-1 md:grid-cols-12 gap-4 md:gap-6 max-w-7xl mx-auto">

        <!-- ===========================
             LEFT PANEL: STATS & HISTORY
             (Desktop: Col 1-3, Row 1-3)
             =========================== -->
        <section class="hidden md:flex md:col-span-3 flex-col gap-4 h-full overflow-hidden">
            <!-- Stats Cards -->
            <div class="bg-white dark:bg-gray-800 rounded-xl p-4 shadow-lg">
                <h3 class="text-xs font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-3">Match Stats</h3>
                <div class="grid grid-cols-2 gap-4">
                    <div class="text-center p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                        <p class="text-xs text-gray-500 dark:text-gray-400 uppercase">Avg (PPR)</p>
                        <p id="ppr-stat-d" class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">0.0</p>
                    </div>
                    <div class="text-center p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                        <p class="text-xs text-gray-500 dark:text-gray-400 uppercase">First 9</p>
                        <p id="f9-stat-d" class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">0.0</p>
                    </div>
                    <div class="text-center p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                        <p class="text-xs text-gray-500 dark:text-gray-400 uppercase">60+</p>
                        <p id="s60-stat-d" class="text-2xl font-bold text-green-600 dark:text-green-400">0</p>
                    </div>
                    <div class="text-center p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                        <p class="text-xs text-gray-500 dark:text-gray-400 uppercase">100+</p>
                        <p id="s100-stat-d" class="text-2xl font-bold text-green-600 dark:text-green-400">0</p>
                    </div>
                </div>
            </div>

            <!-- Score History Table -->
            <div class="flex-grow bg-white dark:bg-gray-800 rounded-xl shadow-lg overflow-hidden flex flex-col">
                <h3 class="text-xs font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider p-4 pb-2">History</h3>
                <div class="flex-grow overflow-y-auto custom-scrollbar px-4 pb-4">
                    <table class="w-full text-sm text-left text-gray-500 dark:text-gray-400">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-100 dark:bg-gray-700 dark:text-gray-400 sticky top-0">
                            <tr>
                                <th scope="col" class="py-2 px-2 rounded-l-lg">#</th>
                                <th scope="col" class="py-2 px-2">Scored</th>
                                <th scope="col" class="py-2 px-2 text-right rounded-r-lg">Left</th>
                            </tr>
                        </thead>
                        <tbody id="score-history-body-d">
                            <!-- History rows injected here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- ===========================
             CENTER PANEL: MAIN SCORE
             (Desktop: Col 4-9, Row 1-3)
             =========================== -->
        <main class="col-span-1 md:col-span-6 flex flex-col justify-between h-full">

            <!-- Header: Controls -->
            <header class="flex justify-between items-center w-full mb-4">
                <!-- Game Mode Toggle -->
                <div class="flex items-center space-x-2 bg-white dark:bg-gray-800 p-2 rounded-lg shadow-sm">
                    <span class="text-xs font-bold text-gray-500 dark:text-gray-400">UP</span>
                    <label for="game-mode-toggle" class="flex items-center cursor-pointer">
                        <input type="checkbox" id="game-mode-toggle" class="sr-only" checked>
                        <div class="toggle-bg relative w-10 h-5 bg-gray-300 dark:bg-gray-600 rounded-full border-2 border-transparent transition-colors"></div>
                    </label>
                    <span class="text-xs font-bold text-indigo-600 dark:text-indigo-400">501</span>
                </div>

                <!-- Undo/Reset -->
                <div class="flex space-x-2">
                    <button id="undo-btn" class="btn-tap bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-1.5 px-3 rounded-lg text-sm shadow-sm focus:outline-none" disabled>
                        Undo
                    </button>
                    <button id="reset-btn" class="btn-tap bg-gray-500 hover:bg-gray-600 text-white font-medium py-1.5 px-3 rounded-lg text-sm shadow-sm focus:outline-none">
                        Reset
                    </button>
                </div>
            </header>

            <!-- Main Score Display -->
            <div class="flex-grow flex flex-col items-center justify-center text-center">
                <p class="text-sm font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Current Score</p>
                <div id="score-display" class="font-black text-indigo-600 dark:text-indigo-400 leading-none my-4" style="font-size: clamp(5rem, 15vw, 10rem);">
                    501
                </div>

                <!-- Turn Info & Last Score -->
                <div class="space-y-2 h-20">
                    <div class="text-2xl font-medium text-gray-700 dark:text-gray-200">
                        Turn: <span id="turn-counter" class="font-bold">1</span>
                    </div>
                    <div id="last-score-info" class="text-xl text-gray-500 dark:text-gray-400 font-medium h-8">
                        <!-- Feedback message -->
                    </div>
                </div>

                <!-- Mobile Only Stats Summary -->
                <div class="md:hidden grid grid-cols-4 gap-2 w-full mt-6">
                     <div class="text-center">
                        <p class="text-[10px] uppercase text-gray-500">PPR</p>
                        <p id="ppr-stat-m" class="text-lg font-bold">0.0</p>
                     </div>
                     <div class="text-center">
                        <p class="text-[10px] uppercase text-gray-500">F9</p>
                        <p id="f9-stat-m" class="text-lg font-bold">0.0</p>
                     </div>
                     <div class="text-center">
                        <p class="text-[10px] uppercase text-gray-500">60+</p>
                        <p id="s60-stat-m" class="text-lg font-bold text-green-600">0</p>
                     </div>
                     <div class="text-center">
                        <p class="text-[10px] uppercase text-gray-500">100+</p>
                        <p id="s100-stat-m" class="text-lg font-bold text-green-600">0</p>
                     </div>
                </div>
            </div>

            <!-- Footer: Mic Button -->
            <div class="flex flex-col items-center space-y-4 pb-2 mt-4">
                <div id="status-message" class="text-center text-xs text-gray-400 h-4">
                    Press mic to start
                </div>
                <button id="toggle-listen-btn" class="btn-tap bg-indigo-600 hover:bg-indigo-700 text-white font-bold w-20 h-20 rounded-full flex items-center justify-center shadow-xl focus:outline-none focus:ring-4 focus:ring-indigo-300 dark:focus:ring-indigo-800 transition-all">
                    <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                    </svg>
                </button>
            </div>
        </main>

        <!-- ===========================
             RIGHT PANEL: MEDIA & CHECKOUT
             (Desktop: Col 10-12, Row 1-3)
             =========================== -->
        <aside class="col-span-1 md:col-span-3 flex flex-col gap-4 h-full overflow-hidden">

            <!-- Video Container -->
            <div id="video-container" class="w-full aspect-video bg-black rounded-xl overflow-hidden shadow-lg relative hidden md:block">
                <video id="camera-stream" class="w-full h-full object-cover transform scale-x-[-1]" autoplay playsinline muted></video>
                <video id="video-playback" class="absolute top-0 left-0 w-full h-full object-cover hidden" controls loop playsinline></video>
                <div class="absolute bottom-2 right-2">
                    <span id="rec-indicator" class="hidden w-3 h-3 bg-red-500 rounded-full animate-pulse"></span>
                </div>
            </div>
            <!-- Mobile Video is hidden by default logic or can be toggled? For now let's keep it visible on mobile if active, or just rely on the desktop layout.
                 Wait, the user wants tablet optimization.
                 I'll duplicate the video container for mobile layout or move it with JS?
                 Actually, let's just make it visible in the flow for mobile too, but maybe smaller.
            -->

            <!-- Checkout Guide -->
            <div id="checkout-guide" class="flex-grow bg-indigo-900 text-white rounded-xl p-4 shadow-lg flex flex-col justify-center items-center text-center transition-opacity duration-300 opacity-0">
                <p class="text-sm uppercase text-indigo-300 font-bold tracking-wider mb-2">Checkout Guide</p>
                <div id="checkout-score" class="text-4xl font-black mb-2 text-white">170</div>
                <div id="checkout-path" class="text-2xl font-medium text-indigo-100 leading-relaxed">
                    T20 T20 Bull
                </div>
            </div>

        </aside>

        <!-- Mobile History (Collapsible or Scrollable?)
             For now, on mobile, history is just a small summary or hidden?
             The original had it below. Let's add a small history section for mobile below the main content if needed.
             Actually, I'll leave the "History" hidden on mobile for now to save space as requested "Stats like 60+ 100+ is enough".
             But I'll make sure the stats summaries are there.
        -->

    </div>

    <!-- Mobile Video Overlay (Optional: To show video on phone without cluttering)
         Or just insert it into the DOM flow on mobile.
         I'll use a simple JS check to move the video element if needed, but CSS Grid order is easier.
         On Mobile: Order is implicit.
         Main (Center) is defined first? No.
         Grid definition:
         Mobile: grid-cols-1. Order: DOM order.
         DOM Order: Left Panel (Hidden), Main (Center), Right Panel (Media).
         So on Mobile: Main -> Media.
         That works perfect. Video will appear below controls.
    -->

    <style>
        /* Mirror the camera stream */
        #camera-stream {
            transform: scaleX(-1);
        }
    </style>

    <script>
        console.log("Darts Scorer script loaded.");

        // --- CONSTANTS ---
        const CHECKOUTS = {
            170: "T20 T20 Bull", 167: "T20 T19 Bull", 164: "T20 T18 Bull", 161: "T20 T17 Bull",
            160: "T20 T20 D20", 158: "T20 T20 D19", 157: "T20 T19 D20", 156: "T20 T20 D18",
            155: "T20 T19 D19", 154: "T20 T18 D20", 153: "T20 T19 D18", 152: "T20 T20 D16",
            151: "T20 T17 D20", 150: "T20 T18 D18", 149: "T20 T19 D16", 148: "T20 T16 D20",
            147: "T20 T17 D18", 146: "T20 T18 D16", 145: "T20 T15 D20", 144: "T20 T20 D12",
            143: "T20 T17 D16", 142: "T20 T14 D20", 141: "T20 T19 D12", 140: "T20 T16 D16",
            139: "T19 T14 D20", 138: "T20 T18 D12", 137: "T19 T16 D16", 136: "T20 T20 D8",
            135: "Bull T15 D20", 134: "T20 T14 D16", 133: "T20 T19 D8", 132: "T20 T16 D12",
            131: "T20 T13 D16", 130: "T20 T20 D5", 129: "T19 T16 D12", 128: "T18 T14 D16",
            127: "T20 T17 D8", 126: "T19 T19 D6", 125: "25 T20 D20", 124: "T20 T16 D8",
            123: "T19 T16 D9", 122: "T18 T20 D4", 121: "T20 T11 D14", 120: "T20 20 D20",
            119: "T19 T10 D16", 118: "T20 18 D20", 117: "T20 17 D20", 116: "T20 16 D20",
            115: "T20 15 D20", 114: "T20 14 D20", 113: "T20 13 D20", 112: "T20 12 D20",
            111: "T20 19 D16", 110: "T20 18 D16", 109: "T20 17 D16", 108: "T20 16 D16",
            107: "T19 18 D16", 106: "T20 14 D16", 105: "T20 13 D16", 104: "T18 18 D16",
            103: "T20 3 D20", 102: "T20 10 D16", 101: "T17 10 D20", 100: "T20 D20",
            99: "T19 10 D16", 98: "T20 D19", 97: "T19 D20", 96: "T20 D18", 95: "T19 D19",
            94: "T18 D20", 93: "T19 D18", 92: "T20 D16", 91: "T17 D20", 90: "T20 D15",
            89: "T19 D16", 88: "T16 D20", 87: "T17 D18", 86: "T18 D16", 85: "T15 D20",
            84: "T20 D12", 83: "T17 D16", 82: "T14 D20", 81: "T19 D12", 80: "T20 D10",
            79: "T19 D11", 78: "T18 D12", 77: "T19 D10", 76: "T20 D8", 75: "T17 D12",
            74: "T14 D16", 73: "T19 D8", 72: "T16 D12", 71: "T13 D16", 70: "T18 D8",
            69: "T19 D6", 68: "T20 D4", 67: "T17 D8", 66: "T10 D18", 65: "T19 D4",
            64: "T16 D8", 63: "T13 D12", 62: "T10 D16", 61: "T15 D8", 60: "20 D20",
            59: "19 D20", 58: "18 D20", 57: "17 D20", 56: "16 D20", 55: "15 D20",
            54: "14 D20", 53: "13 D20", 52: "12 D20", 51: "11 D20", 50: "10 D20",
            49: "9 D20", 48: "16 D16", 47: "15 D16", 46: "6 D20", 45: "13 D16",
            44: "12 D16", 43: "11 D16", 42: "10 D16", 41: "9 D16", 40: "D20"
        };

        // DOM Elements
        const scoreDisplay = document.getElementById('score-display');
        const resetBtn = document.getElementById('reset-btn');
        const undoBtn = document.getElementById('undo-btn');
        const toggleListenBtn = document.getElementById('toggle-listen-btn');
        const statusMessage = document.getElementById('status-message');
        const turnCounter = document.getElementById('turn-counter');
        const lastScoreInfo = document.getElementById('last-score-info');
        const gameModeToggle = document.getElementById('game-mode-toggle');

        // Desktop Stats
        const pprStatD = document.getElementById('ppr-stat-d');
        const f9StatD = document.getElementById('f9-stat-d');
        const s60StatD = document.getElementById('s60-stat-d');
        const s100StatD = document.getElementById('s100-stat-d');
        const scoreHistoryBodyD = document.getElementById('score-history-body-d');

        // Mobile Stats
        const pprStatM = document.getElementById('ppr-stat-m');
        const f9StatM = document.getElementById('f9-stat-m');
        const s60StatM = document.getElementById('s60-stat-m');
        const s100StatM = document.getElementById('s100-stat-m');

        // Video Elements
        const videoContainer = document.getElementById('video-container');
        const cameraStream = document.getElementById('camera-stream');
        const videoPlayback = document.getElementById('video-playback');
        const recIndicator = document.getElementById('rec-indicator');

        // Checkout Elements
        const checkoutGuide = document.getElementById('checkout-guide');
        const checkoutScore = document.getElementById('checkout-score');
        const checkoutPath = document.getElementById('checkout-path');

        // Game State
        let currentScore = 501;
        let previousScore = 501;
        let turn = 1;
        let isGame501 = true;
        let isListening = false;
        let lastTurnState = { score: 501, turn: 1, previousScore: 501 };
        let scoreHistory = [];
        let isScoreLocked = false;

        // Video State
        let mediaRecorder;
        let recordedChunks = [];
        let recordedVideoURL = null;

        // --- Screen Wake Lock ---
        let wakeLock = null;
        let noSleepVideo = null;

        function initNoSleepVideo() {
            if (noSleepVideo) return;
            try {
                noSleepVideo = document.createElement('video');
                noSleepVideo.muted = true;
                noSleepVideo.playsInline = true;
                noSleepVideo.loop = true;
                noSleepVideo.src = "data:video/webm;base64,GkXfo0AgQoaBAAWYgAEdIAYAgAEAAEA8ABgA/iB9f31/f31/fQ==";
                document.body.appendChild(noSleepVideo);
            } catch (e) {
                console.error('Failed to init NoSleep video:', e);
            }
        }

        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    statusMessage.textContent = "Listening... (Screen on)";
                    wakeLock.addEventListener('release', () => wakeLock = null);
                    return;
                } catch (err) {
                    console.warn(`Official Wake Lock failed: ${err.message}.`);
                }
            }
            try {
                if (!noSleepVideo) initNoSleepVideo();
                await noSleepVideo.play();
                statusMessage.textContent = "Listening... (Video hack active)";
            } catch (err) {
                statusMessage.textContent = "Listening...";
            }
        }

        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
            if (noSleepVideo) noSleepVideo.pause();
        }

        document.addEventListener('visibilitychange', async () => {
            if (wakeLock === null && document.visibilityState === 'visible' && isListening) {
                await requestWakeLock();
            }
        });

        // --- Text-to-Speech ---
        const synth = window.speechSynthesis;
        function speak(text) {
            if (!synth || !text) return;
            if (synth.speaking) synth.cancel();
            const utterThis = new SpeechSynthesisUtterance(text);
            synth.speak(utterThis);
        }

        // --- Speech Recognition ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        if (SpeechRecognition) {
            try {
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.lang = 'en-US';
                recognition.interimResults = true;
                recognition.maxAlternatives = 1;

                recognition.onresult = (event) => {
                    let finalTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        }
                    }

                    if (finalTranscript && isListening && !isScoreLocked) {
                        finalTranscript = finalTranscript.trim();
                        console.log(`Heard: "${finalTranscript}"`);
                        statusMessage.textContent = `Heard: "${finalTranscript}"`;
                        const score = parseSpokenNumber(finalTranscript);

                        if (!isNaN(score) && typeof score === 'number' && score >= 0 && score <= 180) {
                            submitScore(score);
                        }
                    }
                };

                recognition.onerror = (event) => {
                    if (event.error === 'not-allowed') {
                        statusMessage.textContent = 'Mic access denied.';
                        isListening = false;
                        toggleListenBtn.disabled = true;
                    }
                };

                recognition.onend = () => {
                    if (isListening) {
                        try { recognition.start(); } catch(e) {}
                    } else {
                        toggleListenBtn.classList.remove('animate-pulse', 'bg-red-500');
                        toggleListenBtn.classList.add('bg-indigo-600');
                        statusMessage.textContent = 'Stopped. Press mic to start.';
                    }
                };

                toggleListenBtn.addEventListener('click', async () => {
                    if (isListening) {
                        isListening = false;
                        recognition.stop();
                        releaseWakeLock();
                        stopCamera();
                    } else {
                        try {
                            await startCamera();
                            recognition.start();
                            isListening = true;
                            statusMessage.textContent = 'Listening...';
                            toggleListenBtn.classList.add('animate-pulse', 'bg-red-500');
                            toggleListenBtn.classList.remove('bg-indigo-600');
                            await requestWakeLock();
                        } catch (e) {
                            statusMessage.textContent = 'Could not start.';
                        }
                    }
                });

            } catch (e) {
                statusMessage.textContent = 'Voice input not supported.';
            }
        } else {
            statusMessage.textContent = 'Voice input not supported.';
        }

        // --- Video Logic ---
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
                videoContainer.classList.remove('hidden');
                cameraStream.srcObject = stream;
                startRecording(stream);
            } catch (err) {
                console.error("Camera error:", err);
                statusMessage.textContent = "Camera access denied.";
            }
        }

        function stopCamera() {
            if (cameraStream.srcObject) {
                cameraStream.srcObject.getTracks().forEach(track => track.stop());
                cameraStream.srcObject = null;
            }
            // videoContainer.classList.add('hidden'); // Keep it visible in layout if desired
        }

        function startRecording(stream, showLiveFeed = true) {
            recordedChunks = [];
            try {
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    if (recordedVideoURL) URL.revokeObjectURL(recordedVideoURL);
                    recordedVideoURL = URL.createObjectURL(blob);

                    // When recording stops, WE SHOW THE REPLAY
                    videoPlayback.src = recordedVideoURL;

                    // Switch Views to Replay
                    cameraStream.classList.add('hidden');
                    videoPlayback.classList.remove('hidden');
                    recIndicator.classList.add('hidden');

                    videoPlayback.play().catch(e => console.error("Autoplay failed:", e));
                };

                mediaRecorder.start();

                if (showLiveFeed) {
                    // Reset View to Live Camera
                    videoPlayback.classList.add('hidden');
                    cameraStream.classList.remove('hidden');
                    recIndicator.classList.remove('hidden');
                } else {
                    // Keep showing whatever was showing (the replay), but show Rec Indicator?
                    // Actually if we are recording in background, we should probably show the Rec indicator on top of the replay?
                    recIndicator.classList.remove('hidden');
                }

            } catch (e) {
                console.error("MediaRecorder error:", e);
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        function parseSpokenNumber(text) {
            const num = parseInt(text, 10);
            if (!isNaN(num) && num >= 0 && num <= 180) return num;

            let lowerText = text.toLowerCase().trim().replace(/ and /g, ' ').replace(/-/g, ' ');
            const specialTerms = {
                'one hundred eighty': 180, 'one eighty': 180, 'hundred eighty': 180, 'ton eighty': 180,
                'treble twenty': 60, 'double twenty': 40, 'bullseye': 50, 'bull': 50,
                'one hundred': 100, 'hundred': 100, 'ton': 100, 'zero': 0, 'nil': 0
            };
            if (specialTerms[lowerText] !== undefined) return specialTerms[lowerText];

            const smallNumbers = { 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15, 'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19 };
            const tens = { 'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50, 'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90 };

            const words = lowerText.split(' ').filter(Boolean);
            let total = 0;
            let tempNum = 0;

            for (const word of words) {
                if (smallNumbers[word]) tempNum += smallNumbers[word];
                else if (tens[word]) tempNum += tens[word];
                else if (word === 'hundred') {
                    tempNum = (tempNum === 0 ? 1 : tempNum) * 100;
                    if (words.indexOf('hundred') < words.length - 1) { total += tempNum; tempNum = 0; }
                }
            }
            total += tempNum;
            return (total > 180 || total < 0) ? NaN : total;
        }

        // --- Game Logic ---
        function submitScore(score) {
            if (isScoreLocked) return;
            isScoreLocked = true;
            console.log(`Submitting score: ${score}`);

            stopRecording(); // Stops recording, shows replay loop

            lastTurnState = { score: currentScore, turn: turn, previousScore: previousScore };
            undoBtn.disabled = false;

            if (isGame501) process501Score(score);
            else processCountUpScore(score);

            // Unlock quickly to allow next input, but keep replay visible
            setTimeout(() => {
                isScoreLocked = false;
                console.log("Score unlocked. Ready for next throw.");

                // We DO NOT switch back to camera here.
                // The replay continues looping until the next submitScore calls stopRecording (which resets it)
                // or we manually restart recording.

                // However, we need to be recording *while* the user is throwing for the *next* turn.
                // If we just show replay, we aren't recording the new throw!
                // User requirement: "Just keep the replay until the next round/score update"

                // Wait, if we show replay, we can't record the next throw with the single camera stream if it's busy playing.
                // But the user said: "keep the replay until the next round/score update".
                // If I am watching the replay, I am not throwing.
                // If I start throwing, I presumably want to record?

                // Let's interpret "keep the replay until the next round" as:
                // Show replay. When user is ready to throw again, they might speak?
                // If they speak, we capture. But we need the BUFFER of the throw.
                // So we MUST be recording in the background even if showing replay?
                // You can't easily record and play different things from same element.
                // But we have <video id="camera-stream"> (hidden) and <video id="video-playback"> (visible).
                // We can keep "camera-stream" active and recording in background?

                // Let's try to restart recording in background immediately, but keep playback visible.
                if (cameraStream.srcObject) {
                     startRecording(cameraStream.srcObject, false); // false = do not switch UI
                }
            }, 2000);
        }

        function process501Score(score) {
            const newScore = currentScore - score;
            if (newScore < 0 || newScore === 1) {
                scoreHistory.push({ turn: turn, score: score, remainingScore: "Bust" });
                showBust("Bust!");
            } else if (newScore === 0) {
                scoreHistory.push({ turn: turn, score: score, remainingScore: 0 });
                currentScore = 0;
                lastScoreInfo.textContent = `Check out! (${score})`;
                showWin();
            } else {
                previousScore = currentScore;
                currentScore = newScore;
                scoreHistory.push({ turn: turn, score: score, remainingScore: currentScore });
                turn++;
                lastScoreInfo.textContent = `Scored: ${score}`;
                lastScoreInfo.classList.remove('text-red-500');
                updateDisplay();
                updateStats();
                speak(currentScore.toString());
            }
        }

        function processCountUpScore(score) {
            if (score < 0) return;
            currentScore += score;
            scoreHistory.push({ turn: turn, score: score, remainingScore: currentScore });
            turn++;
            lastScoreInfo.textContent = `Added: ${score}`;
            updateDisplay();
            updateStats();
            speak(currentScore.toString());
        }

        function showBust(message) {
            currentScore = previousScore;
            turn++;
            lastScoreInfo.textContent = message;
            lastScoreInfo.classList.add('text-red-500');
            updateDisplay();
            updateStats();
            speak(message);
        }

        function showWin() {
            lastScoreInfo.textContent = 'GAME OVER! WINNER!';
            lastScoreInfo.classList.add('text-green-500');
            if (isListening) { isListening = false; recognition.stop(); }
            releaseWakeLock();
            toggleListenBtn.disabled = true;
            updateDisplay();
            updateStats();
            speak('Game over! You win!');
        }

        function updateCheckoutGuide() {
            if (!isGame501 || currentScore > 170 || currentScore <= 1) {
                checkoutGuide.classList.add('opacity-0');
                return;
            }

            let checkout = CHECKOUTS[currentScore];

            // Simple fallback for numbers < 40 if not in map
            if (!checkout && currentScore < 40) {
                 if (currentScore % 2 === 0) checkout = `D${currentScore/2}`;
                 else checkout = `1 D${(currentScore-1)/2}`;
            }

            if (checkout) {
                checkoutScore.textContent = currentScore;
                checkoutPath.textContent = checkout;
                checkoutGuide.classList.remove('opacity-0');
            } else {
                checkoutGuide.classList.add('opacity-0');
            }
        }

        function updateDisplay() {
            scoreDisplay.textContent = currentScore;
            turnCounter.textContent = turn;
            undoBtn.disabled = (turn === 1);
            updateCheckoutGuide();
            updateScoreHistoryDisplay();
        }

        function updateStats() {
            const turnsPlayed = scoreHistory.length;
            if (turnsPlayed === 0) {
                setStats('0.0', '0.0', 0, 0);
                return;
            }

            const totalScored = scoreHistory.reduce((a, b) => a + b.score, 0);
            const ppr = (totalScored / turnsPlayed).toFixed(1);

            let f9Avg = '...';
            if (turnsPlayed >= 3) {
                const firstThree = scoreHistory.slice(0, 3).reduce((a, b) => a + b.score, 0);
                f9Avg = (firstThree / 3.0).toFixed(1);
            }

            const s60 = scoreHistory.filter(t => t.score >= 60).length;
            const s100 = scoreHistory.filter(t => t.score >= 100).length;

            setStats(ppr, f9Avg, s60, s100);
        }

        function setStats(ppr, f9, s60, s100) {
            pprStatD.textContent = ppr;
            f9StatD.textContent = f9;
            s60StatD.textContent = s60;
            s100StatD.textContent = s100;

            pprStatM.textContent = ppr;
            f9StatM.textContent = f9;
            s60StatM.textContent = s60;
            s100StatM.textContent = s100;
        }

        function updateScoreHistoryDisplay() {
            scoreHistoryBodyD.innerHTML = '';
            // Show latest on top
            for (let i = scoreHistory.length - 1; i >= 0; i--) {
                const entry = scoreHistory[i];
                const row = document.createElement('tr');
                row.className = 'border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors';
                row.innerHTML = `
                    <td class="py-2 px-2 text-gray-900 dark:text-white font-medium">${entry.turn}</td>
                    <td class="py-2 px-2 text-indigo-600 dark:text-indigo-400 font-bold">${entry.score}</td>
                    <td class="py-2 px-2 text-right text-gray-500 dark:text-gray-400">${entry.remainingScore}</td>
                `;
                scoreHistoryBodyD.appendChild(row);
            }
        }

        // --- Controls ---
        resetBtn.addEventListener('click', resetGame);
        undoBtn.addEventListener('click', () => {
            if (turn === 1) return;
            currentScore = lastTurnState.score;
            turn = lastTurnState.turn;
            previousScore = lastTurnState.previousScore;
            scoreHistory.pop();
            updateDisplay();
            updateStats();
            lastScoreInfo.textContent = 'Score undone.';
            lastScoreInfo.classList.remove('text-red-500');
            undoBtn.disabled = true;
        });

        gameModeToggle.addEventListener('change', () => {
            isGame501 = gameModeToggle.checked;
            resetGame();
        });

        function resetGame() {
            isScoreLocked = false;
            if (isGame501) { currentScore = 501; previousScore = 501; }
            else { currentScore = 0; previousScore = 0; }
            turn = 1;
            lastTurnState = { score: currentScore, turn: 1, previousScore: previousScore };
            scoreHistory = [];
            updateDisplay();
            updateStats();
            lastScoreInfo.textContent = '';
            if (isListening) { isListening = false; recognition.stop(); }
            releaseWakeLock();
            stopCamera();
            statusMessage.textContent = 'Game reset. Press mic to start.';
            speak('Game reset.');
        }

        // Init
        updateDisplay();
        updateStats();

    </script>
</body>
</html>
